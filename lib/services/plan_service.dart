import 'package:supabase_flutter/supabase_flutter.dart';
import 'dto/plan_dto.dart';

class PlanService {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// Save the plan into domain tables: workout_plan, relax_plan, and meal_plan.
  /// Uses DTOs to transform AI output into DB rows.
  /// Also links created rows to `user_identity` via `exercise_id` and `relax_id`.
  Future<void> saveChildTables({
    required Map<String, dynamic> survey,
    required Map<String, dynamic> plan,
  }) async {
    final user = _supabase.auth.currentUser;
    if (user == null) {
      throw Exception('Please sign in to save your plan.');
    }
    // Build DTOs from AI plan and survey
    final bundle = PlanInsertDTOs.fromPlanSurvey(
      plan: plan,
      survey: survey,
      userId: user.id,
      mapGoalToCategory: _mapGoalToCategory,
    );
    final workoutInserts = bundle.workout.map((e) => e.toMap()).toList();
    final relaxInserts = bundle.relax.map((e) => e.toMap()).toList();

    // Best-effort cleanup to avoid duplicate plans on repeated saves
    try {
      await _supabase.from('meal_plan').delete().eq('user_id', user.id);
    } catch (_) {}
    try {
      await _supabase.from('workout_plan').delete().eq('user_id', user.id);
    } catch (_) {}
    try {
      await _supabase.from('relax_plan').delete().eq('user_id', user.id);
    } catch (_) {}

    // Insert workout items (multi-row)
    Map<String, dynamic>? firstWorkoutRow;
    if (workoutInserts.isNotEmpty) {
      try {
        final resp = await _supabase
            .from('workout_plan')
            .insert(workoutInserts)
            .select()
            .limit(1);
        if (resp is List && resp.isNotEmpty) {
          firstWorkoutRow = Map<String, dynamic>.from(resp.first as Map);
        }
      } on PostgrestException catch (e) {
        final code = e.code ?? '';
        final msg = e.message ?? '';
        if (code == '42703' || msg.contains('column') && msg.contains('user_id')) {
          final fallback = workoutInserts
              .map((m) => Map<String, dynamic>.from(m)..remove('user_id'))
              .toList();
          final resp = await _supabase
              .from('workout_plan')
              .insert(fallback)
              .select()
              .limit(1);
          if (resp is List && resp.isNotEmpty) {
            firstWorkoutRow = Map<String, dynamic>.from(resp.first as Map);
          }
        } else {
          _throwHelpfulPolicyError('workout_plan', e);
        }
      }
    }

    // Insert relax items (multi-row)
    Map<String, dynamic>? firstRelaxRow;
    if (relaxInserts.isNotEmpty) {
      try {
        final resp = await _supabase
            .from('relax_plan')
            .insert(relaxInserts)
            .select()
            .limit(1);
        if (resp is List && resp.isNotEmpty) {
          firstRelaxRow = Map<String, dynamic>.from(resp.first as Map);
        }
      } on PostgrestException catch (e) {
        final code = e.code ?? '';
        final msg = e.message ?? '';
        if (code == '42703' || msg.contains('column') && msg.contains('user_id')) {
          final fallback = relaxInserts
              .map((m) => Map<String, dynamic>.from(m)..remove('user_id'))
              .toList();
          final resp = await _supabase
              .from('relax_plan')
              .insert(fallback)
              .select()
              .limit(1);
          if (resp is List && resp.isNotEmpty) {
            firstRelaxRow = Map<String, dynamic>.from(resp.first as Map);
          }
        } else {
          _throwHelpfulPolicyError('relax_plan', e);
        }
      }
    }

    // Insert meal_plan rows (one per day) from DTOs
    try {
      final mealInserts = bundle.meals.map((e) => e.toMap()).toList();
      if (mealInserts.isNotEmpty) {
        // Insert sequentially to avoid any partial-batch issues and ensure
        // all 7 days are persisted even if one row has problematic data.
        for (final row in mealInserts) {
          await _supabase.from('meal_plan').insert(row);
        }
      }
    } on PostgrestException catch (e) {
      final code = e.code ?? '';
      final msg = e.message ?? '';
      if (code == '42P01' || msg.contains('relation "meal_plan" does not exist')) {
        throw Exception(
          'Table meal_plan not found. Please run this SQL in Supabase to enable saving meals:\n\n'
          'create table if not exists public.meal_plan (\n'
          '  id bigint generated by default as identity primary key,\n'
          '  user_id uuid references auth.users(id) on delete cascade,\n'
          '  day_index int not null,\n'
          '  day_label text,\n'
          '  meals jsonb not null,\n'
          '  snacks jsonb,\n'
          '  created_at timestamptz not null default now()\n'
          ');\n\n'
          'alter table public.meal_plan enable row level security;\n'
          'create policy "Select own" on public.meal_plan for select using (auth.uid() = user_id);\n'
          'create policy "Insert own" on public.meal_plan for insert with check (auth.uid() = user_id);\n'
          'create policy "Update own" on public.meal_plan for update using (auth.uid() = user_id) with check (auth.uid() = user_id);\n'
          'create policy "Delete own" on public.meal_plan for delete using (auth.uid() = user_id);',
        );
      }
      rethrow;
    }

    // Link created rows to user_identity
    try {
      final uid = user.id;
      final existing = await _supabase
          .from('user_identity')
          .select('id')
          .eq('user_id', uid)
          .maybeSingle();
      // Parse macros from plan if available
      int? _asInt(dynamic v) {
        if (v == null) return null;
        if (v is int) return v;
        if (v is double) return v.round();
        final s = v.toString().trim();
        if (s.isEmpty) return null;
        // Strip common units and separators
        final cleaned = s
            .replaceAll(RegExp(r'[^0-9.\-]'), '') // keep digits, dot, minus
            .replaceAll(',', '');
        final numVal = double.tryParse(cleaned);
        return numVal?.round();
      }
      final macros = plan['calorie_and_macros'];
      final updatePayload = <String, dynamic>{
        if (firstWorkoutRow != null && firstWorkoutRow['id'] != null) 'exercise_id': firstWorkoutRow['id'],
        if (firstRelaxRow != null && firstRelaxRow['id'] != null) 'relax_id': firstRelaxRow['id'],
        if (survey['diet_type'] != null) 'diet_type': survey['diet_type'].toString(),
        if (macros is Map && macros['calories'] != null) 'calories': _asInt(macros['calories']),
        if (macros is Map && macros['protein_g'] != null) 'protein': _asInt(macros['protein_g']),
        if (macros is Map && macros['carbs_g'] != null) 'carbs': _asInt(macros['carbs_g']),
        if (macros is Map && macros['fat_g'] != null) 'fat': _asInt(macros['fat_g']),
      };
      if (existing == null) {
        await _supabase.from('user_identity').insert({
          'user_id': uid,
          ...updatePayload,
        });
      } else {
        await _supabase
            .from('user_identity')
            .update(updatePayload)
            .eq('user_id', uid);
      }
    } catch (e) {
      // Non-fatal; user_identity linkage may fail if RLS prohibits updates
      // Ignore silently but could be logged if needed.
    }
  }

  String _mapGoalToCategory(String? goal) {
    switch (goal) {
      case 'lost_weight':
      case 'lose_weight':
        return 'weight_loss';
      case 'gain_weight':
        return 'muscle_gain';
      case 'maintain_weight':
      default:
        return 'maintenance';
    }
  }

  Never _throwHelpfulPolicyError(String table, PostgrestException e) {
    final code = e.code ?? '';
    final msg = e.message ?? '';
    // If table missing or RLS blocks, provide guidance
    if (code == '42P01' || msg.contains('does not exist')) {
      throw Exception('Table $table not found. Please create it in Supabase or ensure it matches the app schema.');
    }
    if (code == '42703' || msg.contains('column') && msg.contains('user_id')) {
      throw Exception(
        'Column user_id missing on "$table". To enable owner-based RLS, run:\n\n'
        'alter table public.$table add column user_id uuid references auth.users(id) on delete cascade;\n'
        'alter table public.$table enable row level security;\n'
        'create policy "Select own" on public.$table for select using (auth.uid() = user_id);\n'
        'create policy "Insert own" on public.$table for insert with check (auth.uid() = user_id);\n'
        'create policy "Update own" on public.$table for update using (auth.uid() = user_id) with check (auth.uid() = user_id);\n'
        'create policy "Delete own" on public.$table for delete using (auth.uid() = user_id);',
      );
    }
    if (msg.contains('new row violates row-level security policy') || msg.toLowerCase().contains('rls')) {
      throw Exception(
        'RLS prevented writing to "$table". Ensure appropriate policies exist to allow authenticated users to insert/select.\n'
        'Owner-based example:\n'
        '  alter table public.$table enable row level security;\n'
        '  create policy "Select own" on public.$table for select using (auth.uid() = user_id);\n'
        '  create policy "Insert own" on public.$table for insert with check (auth.uid() = user_id);\n'
        '  create policy "Update own" on public.$table for update using (auth.uid() = user_id) with check (auth.uid() = user_id);\n'
        '  create policy "Delete own" on public.$table for delete using (auth.uid() = user_id);',
      );
    }
    throw e;
  }
}
