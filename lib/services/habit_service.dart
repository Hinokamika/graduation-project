import 'package:supabase_flutter/supabase_flutter.dart';

class HabitService {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// Upsert (insert or update) today's metrics for the signed-in user.
  /// If a row already exists for (user_id, bucket_date) it is updated;
  /// otherwise a new row is inserted.
  Future<void> upsertTodayMetrics({
    int? steps,
    int? calories,
    int? standingTimeMinutes,
    double? sleepHours,
    int? standingMinutes,
    int? heartRateAvg,
    String? sleepStartTime, // HH:MM or HH:MM:SS (local time)
  }) async {
    final user = _supabase.auth.currentUser;
    if (user == null) {
      throw Exception('Please sign in to update your daily metrics.');
    }

    final now = DateTime.now();
    final bucketDate = _formatDate(now); // YYYY-MM-DD (local date)

    final payload = <String, dynamic>{
      'user_id': user.id,
      'bucket_date': bucketDate,
      if (steps != null) 'steps': steps,
      if (calories != null) 'calories': calories,
      // Store standing time minutes in the canonical column
      if (standingTimeMinutes != null) 'standing_minutes': standingTimeMinutes,
      if (sleepHours != null)
        'sleep_hours': double.parse(sleepHours.toStringAsFixed(1)),
      if (standingMinutes != null) 'standing_minutes': standingMinutes,
      if (heartRateAvg != null) 'heart_rate_avg': heartRateAvg,
      if (sleepStartTime != null && sleepStartTime.trim().isNotEmpty)
        'sleep_start_time': _normalizeTimeString(sleepStartTime.trim()),
    };

    try {
      await _supabase
          .from('habit')
          .upsert(payload, onConflict: 'user_id,bucket_date');
    } on PostgrestException catch (e) {
      final code = e.code ?? '';
      final msg = e.message;
      if (code == '42P01' ||
          (msg.toLowerCase().contains('relation') &&
              msg.toLowerCase().contains('habit') &&
              msg.toLowerCase().contains('does not exist'))) {
        throw Exception(
          'Table habit not found. Please create it in Supabase:\\n\\n'
          'create table if not exists public.habit (\\n'
          '  id bigint generated by default as identity primary key,\\n'
          '  user_id uuid not null references auth.users(id) on delete cascade,\\n'
          '  bucket_date date not null,\\n'
          '  steps integer,\\n'
          '  calories integer,\\n'
          '  standing_time_minutes integer,\\n'
          '  sleep_hours numeric(4,1),\\n'
          '  standing_minutes integer,\\n'
          '  heart_rate_avg integer,\\n'
          '  sleep_start_time time,\\n'
          '  created_at timestamptz not null default now()\\n'
          ');\\n'
          'create unique index if not exists habit_unique_user_date on public.habit (user_id, bucket_date);\\n'
          'alter table public.habit enable row level security;\\n'
          'create policy "Select own" on public.habit for select using (auth.uid() = user_id);\\n'
          'create policy "Insert own" on public.habit for insert with check (auth.uid() = user_id);\\n'
          'create policy "Update own" on public.habit for update using (auth.uid() = user_id) with check (auth.uid() = user_id);\\n'
          'create policy "Delete own" on public.habit for delete using (auth.uid() = user_id);',
        );
      }
      rethrow;
    }
  }

  /// Fetch metrics between start and end date (inclusive). Dates are local.
  Future<List<Map<String, dynamic>>> getMetricsRange(
    DateTime start,
    DateTime end,
  ) async {
    final user = _supabase.auth.currentUser;
    if (user == null) return [];
    final startStr = _formatDate(start);
    final endStr = _formatDate(end);
    final resp = await _supabase
        .from('habit')
        .select()
        .eq('user_id', user.id)
        .gte('bucket_date', startStr)
        .lte('bucket_date', endStr)
        .order('bucket_date', ascending: true);
    return List<Map<String, dynamic>>.from(resp);
  }

  String _formatDate(DateTime dt) {
    final y = dt.year.toString().padLeft(4, '0');
    final m = dt.month.toString().padLeft(2, '0');
    final d = dt.day.toString().padLeft(2, '0');
    return '$y-$m-$d';
  }

  String _normalizeTimeString(String t) {
    // Accept HH:MM or HH:MM:SS and normalize to HH:MM:SS
    final parts = t.split(':');
    if (parts.length == 2) {
      return '${parts[0].padLeft(2, '0')}:${parts[1].padLeft(2, '0')}:00';
    }
    if (parts.length >= 3) {
      return '${parts[0].padLeft(2, '0')}:${parts[1].padLeft(2, '0')}:${parts[2].padLeft(2, '0')}';
    }
    return t; // fallback
  }
}
